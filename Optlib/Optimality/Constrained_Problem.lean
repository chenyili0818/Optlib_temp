/-
Copyright (c) 2024 Chenyi Li. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Chenyi Li, Shengyang Xu, Yuxuan Wu
-/
import Mathlib.Analysis.Convex.Cone.Basic
import Mathlib.Analysis.Calculus.LocalExtr.Basic
import Mathlib.Analysis.NormedSpace.HahnBanach.Separation
import Mathlib.Data.Matrix.Rank
import Mathlib.LinearAlgebra.FiniteDimensional
import Mathlib.Analysis.Calculus.Implicit
import Mathlib.Analysis.Calculus.MeanValue
import Mathlib.Analysis.InnerProductSpace.Calculus
import Optlib.Differential.Calculation
import Optlib.Convex.Farkas
import Optlib.Differential.Lemmas

/-!
# Constrained_Problem

## Main results

This file contains the following parts of constrained optimization problem.
* the definition of a constrained optimization prblem
* the definition of a local minima, global minima, strict local minima
* the definition of the active set
* the definition of the linearized feasible directions
* the proof of the creteria of the geometry optimality condition
* the proof of LICQ which states under suitable conditions the positive tangent cone
  equals the linearized feasible directions
* the proof of KKT conditions under LICQ
-/

open InnerProductSpace Set BigOperators

noncomputable section

variable {E : Type _} [NormedAddCommGroup E] [InnerProductSpace ‚Ñù E] [CompleteSpace E]
variable {œÑ œÉ : Finset ‚Ñï}

/-
  the definition of an unconstrained optimization problem.
  The objective function is a function from a Hilbert space to ‚Ñù.
  The equality constraints are a set of functions from a Hilbert space to ‚Ñù.
  The inequality constraints are a set of functions from a Hilbert space to ‚Ñù.
-/
structure Constrained_OptimizationProblem (E : Type _) (œÑ œÉ : Finset ‚Ñï) :=
  (domain : Set E)
  (equality_constraints : (i : ‚Ñï) ‚Üí E ‚Üí ‚Ñù)
  (inequality_constraints : (j : ‚Ñï) ‚Üí E ‚Üí ‚Ñù)
  (eq_ine_not_intersect : œÑ ‚à© œÉ = ‚àÖ)
  (objective : E ‚Üí ‚Ñù)

namespace Constrained_OptimizationProblem

variable {p : Constrained_OptimizationProblem E œÑ œÉ} {x : E}

open Topology InnerProductSpace Set Filter Tendsto

/-
  The feasible point is a point that satisfies all the constraints.
-/
def FeasPoint (point : E) : Prop :=
  point ‚àà p.domain ‚àß (‚àÄ i ‚àà œÑ, p.equality_constraints i point = 0)
  ‚àß (‚àÄ j ‚àà œÉ, p.inequality_constraints j point ‚â• 0)

/-
  The feasible set is the set that satisfies all the constraints. Denote the set as Œ©
-/
def FeasSet : Set E :=
  {point | p.FeasPoint point}

/-
  A point x‚ÇÅ ‚àà Œ© is a global minimizer if f x‚ÇÅ ‚â§ f x for all x ‚àà Œ©.
-/
def Global_Minima (point : E) : Prop :=
  (p.FeasPoint point) ‚àß IsMinOn p.objective p.FeasSet point

/-
  A point x‚ÇÅ ‚àà Œ© is a local minimizer if there is a neighborhood B of x‚ÇÅ
  such that f x‚ÇÅ ‚â§ f x for all x ‚àà B ‚à© Œ©.
-/
def Local_Minima (point : E) : Prop :=
  (p.FeasPoint point) ‚àß IsLocalMinOn p.objective p.FeasSet point

/-
  A vector x‚àó is a strict local solution (also called a strong local solution) if x‚àó ‚àà Œ© and there
  is a neighborhood B of x‚àó such that f (x) > f (x‚àó) for all x ‚àà B ‚à© Œ© with x ‚â† x‚àó.
-/
def Strict_Local_Minima (point : E) : Prop :=
  (p.FeasPoint point) ‚àß (‚àÉ Œµ > 0, ‚àÄ y, p.FeasPoint y ‚Üí y ‚àà Metric.ball point Œµ ‚Üí y ‚â† point
  ‚Üí p.objective point > p.objective y)

/-
  The active set A(x) at any feasible x consists of the equality constraint indices from E
  together with the indices of the inequality constraints i for which c_i(x) = 0;
-/
def active_set (point : E) : Finset ‚Ñï :=
  œÑ ‚à™ œÉ.filter fun i : ‚Ñï ‚Ü¶ p.inequality_constraints i point = (0 : ‚Ñù)

/-
  Given a feasible point x and the active constraint set A(x) of Definition 12.1, the set of
  linearized feasible directions is defined as
-/
def linearized_feasible_directions (point : E) : Set E :=
  {v | (‚àÄ i ‚àà œÑ, ‚ü™gradient (p.equality_constraints i) point, v ‚ü´_‚Ñù = (0 : ‚Ñù))
    ‚àß ‚àÄ j ‚àà œÉ ‚à© (p.active_set point), ‚ü™gradient (p.inequality_constraints j) point, v‚ü´_‚Ñù ‚â• (0 : ‚Ñù)}

/-
  Given the point x and the active set A(x), we say that the linear
  independence constraint qualification (LICQ) holds if the set of active constraint gradients
  {‚àáci(x), i ‚àà A(x)} is linearly independent.
-/
def LICQ (point : E) : Prop :=
  LinearIndependent ‚Ñù (fun i : p.active_set point ‚Ü¶
    if i.1 ‚àà œÑ then gradient (p.equality_constraints i.1) point else gradient (p.inequality_constraints i.1) point)

/-
  Lagrangian function for the general problem
-/
def Lagrange_function :=
  fun (x : E) (lambda1 : œÑ ‚Üí ‚Ñù) (lambda2 : œÉ ‚Üí ‚Ñù) ‚Ü¶ (p.objective x)
    - (Finset.sum Finset.univ fun i ‚Ü¶ (lambda1 i) * p.equality_constraints i x)
    - (Finset.sum Finset.univ fun j ‚Ü¶ (lambda2 j) * p.inequality_constraints j x)

end Constrained_OptimizationProblem

end

section Constrained_OptimizationProblem_property_general

open Constrained_OptimizationProblem Topology InnerProductSpace Set Filter Tendsto

variable {E : Type _} [NormedAddCommGroup E] [InnerProductSpace ‚Ñù E] [CompleteSpace E]

variable {œÑ œÉ : Finset ‚Ñï} {p : Constrained_OptimizationProblem E œÑ œÉ} {x : E} {n : ‚Ñï}

/-
  The set of linearized_feasible_directions is a convex set
-/
theorem linearized_feasible_directions_convex (point : E) :
    Convex ‚Ñù (p.linearized_feasible_directions point) := by
  intro v‚ÇÅ h‚ÇÅ v‚ÇÇ h‚ÇÇ a b ha hb hab
  rw [linearized_feasible_directions] at h‚ÇÅ h‚ÇÇ; rw [linearized_feasible_directions]
  dsimp at h‚ÇÅ h‚ÇÇ; dsimp
  constructor
  ¬∑ rcases h‚ÇÅ with ‚ü®h‚ÇÅ, _‚ü©
    rcases h‚ÇÇ with ‚ü®h‚ÇÇ, _‚ü©
    intro i itau
    rw [inner_add_right, real_inner_smul_right, real_inner_smul_right, (h‚ÇÅ i itau), (h‚ÇÇ i itau)]
    linarith
  ¬∑ rcases h‚ÇÅ with ‚ü®_, h‚ÇÅ‚ü©
    rcases h‚ÇÇ with ‚ü®_, h‚ÇÇ‚ü©
    intro j jsigma
    rw [inner_add_right, real_inner_smul_right, real_inner_smul_right]
    apply add_nonneg
    . apply mul_nonneg ha (h‚ÇÅ j jsigma)
    . apply mul_nonneg hb (h‚ÇÇ j jsigma)

lemma posTangentCone_localmin_inner_pos {f : E ‚Üí ‚Ñù} {loc : E} (hl : IsLocalMinOn f p.FeasSet loc)
    (hf : DifferentiableAt ‚Ñù f loc) :
    ‚àÄ v ‚àà posTangentConeAt p.FeasSet loc, ‚ü™gradient f loc, v‚ü´_‚Ñù ‚â• (0 : ‚Ñù) := by
  intro v vt; rw [posTangentConeAt] at vt; simp at vt
  rcases vt with ‚ü®c, d, ‚ü®a, ha‚ü©, ‚ü®vt1, vt2‚ü©‚ü©
  by_contra proneg; push_neg at proneg
  rw [IsLocalMinOn, IsMinFilter, eventually_iff_exists_mem] at hl
  rcases hl with ‚ü®s, ‚ü®hs, hs2‚ü©‚ü©
  rw [nhdsWithin] at hs
  rcases Metric.mem_nhdsWithin_iff.mp hs with ‚ü®Œµ, ‚ü®Œµpos, Œµball‚ü©‚ü©
  let s1 := Metric.ball loc Œµ ‚à© p.FeasSet
  have hmin : ‚àÄ y ‚àà s1, f loc ‚â§ f y := fun y yin => hs2 y (Œµball yin)
  let z := fun n ‚Ü¶ loc + d n
  have hzd : ‚àÄ n, d n = z n - loc := fun _ => eq_sub_of_add_eq' rfl
  rw [real_inner_comm] at proneg
  have hcp : ‚àÄ·∂† (n : ‚Ñï) in atTop, c n > 0 := by
    rw [Filter.tendsto_atTop] at vt1
    specialize vt1 (1 : ‚Ñù)
    apply Filter.Eventually.mp vt1
    apply Filter.Eventually.of_forall
    intro n hn; linarith
  have hz3 : ‚àÄ·∂† (n : ‚Ñï) in atTop, (1 / c n) > 0 := by
    apply Filter.Eventually.mp hcp
    apply Filter.Eventually.of_forall
    intro n hn; exact one_div_pos.mpr hn
  have hzt : Tendsto z atTop (ùìù loc) := by
    have : Tendsto d atTop (ùìù 0) := by
      rw [Filter.tendsto_atTop] at vt1
      rw [Filter.tendsto_atTop'] at vt2
      rw [Metric.tendsto_atTop']; intro Œµ hŒµ
      have : Metric.ball v Œµ ‚àà ùìù v := by exact Metric.ball_mem_nhds _ hŒµ
      specialize vt2 (Metric.ball v Œµ) this
      rcases vt2 with ‚ü®a, ha‚ü©
      specialize vt1 (2 * (‚Äñv‚Äñ + Œµ) / Œµ); simp at vt1
      rcases vt1 with ‚ü®a1, ha1‚ü©
      let n1 := max a a1
      use n1; intro n hn
      specialize ha n (ge_trans (Nat.le_of_lt hn) (a.le_max_left a1))
      specialize ha1 n (ge_trans (Nat.le_of_lt hn) (a.le_max_right a1))
      have : ‚Äñd n‚Äñ < Œµ := by
        have : ‚Äñc n ‚Ä¢ d n‚Äñ ‚â§ ‚Äñv‚Äñ + Œµ := by
          rw [Metric.mem_ball, dist_eq_norm] at ha;
          have t1 : ‚Äñc n ‚Ä¢ d n - v‚Äñ ‚â• ‚Äñc n ‚Ä¢ d n‚Äñ - ‚Äñv‚Äñ := norm_sub_norm_le _ v
          linarith
        have cpos : c n > 0 := by
          apply lt_of_le_of_lt'
          ¬∑ show c n ‚â• 2 * (‚Äñv‚Äñ + Œµ) / Œµ
            exact ha1
          ¬∑ positivity
        rw [norm_smul, Real.norm_eq_abs, abs_of_pos cpos] at this;
        calc _ ‚â§ (‚Äñv‚Äñ + Œµ) / c n := (le_div_iff' cpos).mpr this
             _ ‚â§ (‚Äñv‚Äñ + Œµ) / (2 * (‚Äñv‚Äñ + Œµ) / Œµ) :=
                div_le_div_of_nonneg_left (by positivity) (by positivity) ha1
             _ = Œµ / 2 := by field_simp [Œµpos]; ring_nf
             _ < Œµ := by linarith
      simp; exact this
    have h1 : z = (fun n ‚Ü¶ d n + loc) := by
      funext n; rw [hzd n, sub_add, sub_self, sub_zero]
    rw [h1]
    convert Filter.Tendsto.add_const loc this
    rw [zero_add]
  have hz : (fun n ‚Ü¶ f (z n) - f loc - inner (z n - loc) (gradient f loc))
      =o[atTop] (fun n ‚Ü¶ z n - loc) := by
    have : HasGradientAt f (gradient f loc) loc := hf.hasGradientAt
    rw [hasGradientAt_iff_isLittleO] at this
    have heq : (fun n ‚Ü¶ f (z n) - f loc - inner (z n - loc) (gradient f loc)) =
        (fun n ‚Ü¶ f (z n) - f loc - inner (gradient f loc) (z n - loc)) := by
      ext n; rw [real_inner_comm]
    rw [heq]
    apply Asymptotics.IsLittleO.comp_tendsto this hzt
  have hz1 : (fun n ‚Ü¶ f (z n) - f loc - (1 / c n) * inner v (gradient f loc))
      =o[atTop] (fun n ‚Ü¶ 1 / c n) := by
    have t1: (fun n ‚Ü¶ z n - loc) =O[atTop] (fun n ‚Ü¶ 1 / c n) := by
      rw [Asymptotics.isBigO_iff]
      rw [Filter.tendsto_atTop] at vt1
      rw [Filter.tendsto_atTop'] at vt2
      have : Metric.ball v 1 ‚àà ùìù v := by exact Metric.ball_mem_nhds _ (by norm_num)
      specialize vt2 (Metric.ball v 1) this
      rcases vt2 with ‚ü®a, ha‚ü©
      specialize vt1 (2 * (‚Äñv‚Äñ + Œµ) / Œµ); simp at vt1
      rcases vt1 with ‚ü®a1, ha1‚ü©
      let n1 := max a a1
      use (‚Äñv‚Äñ + 1 : ‚Ñù); simp; use n1; intro n hn
      specialize ha n (ge_trans hn (a.le_max_left a1))
      specialize ha1 n (ge_trans hn (a.le_max_right a1))
      have cpos : c n > 0 := by
          apply lt_of_le_of_lt'
          ¬∑ show c n ‚â• 2 * (‚Äñv‚Äñ + Œµ) / Œµ
            exact ha1
          ¬∑ positivity
      rw [abs_of_pos]
      have : ‚Äñd n‚Äñ ‚â§ (‚Äñv‚Äñ + 1) * (c n)‚Åª¬π := by
        have : ‚Äñc n ‚Ä¢ d n‚Äñ ‚â§ ‚Äñv‚Äñ + 1 := by
          rw [Metric.mem_ball, dist_eq_norm] at ha;
          have t1 : ‚Äñc n ‚Ä¢ d n - v‚Äñ ‚â• ‚Äñc n ‚Ä¢ d n‚Äñ - ‚Äñv‚Äñ := norm_sub_norm_le _ v
          linarith
        rw [norm_smul, Real.norm_eq_abs, abs_of_pos cpos] at this;
        field_simp; exact (le_div_iff' cpos).mpr this
      rw [‚Üê hzd n]; exact this; apply cpos
    have t2 : (fun n ‚Ü¶ f (z n) - f loc - inner (z n - loc) (gradient f loc))
        =o[atTop] (fun n ‚Ü¶ 1 / c n) := Asymptotics.IsLittleO.trans_isBigO hz t1
    have t3 : (fun n ‚Ü¶ (inner (z n - loc - (1 / c n) ‚Ä¢ v) (gradient f loc) : ‚Ñù))
        =o[atTop] (fun n ‚Ü¶ 1 / c n) := by
      have t5: (fun n ‚Ü¶ z n - loc - (1 / c n) ‚Ä¢ v) =o[atTop] (fun n ‚Ü¶ 1 / c n) := by
        rw [‚Üê Asymptotics.isLittleO_norm_norm]
        apply (Asymptotics.isLittleO_iff_tendsto' _).mpr
        ¬∑ have : (fun x ‚Ü¶ ‚Äñz x - loc - (1 / c x) ‚Ä¢ v‚Äñ / ‚Äñ1 / c x‚Äñ)
              =·∂†[atTop] (fun x ‚Ü¶ ‚Äñc x ‚Ä¢ (z x - loc) - v‚Äñ) := by
            simp; rw [Filter.EventuallyEq]
            apply Filter.Eventually.mp hcp
            apply Filter.Eventually.of_forall
            intro n hcn1; rw [mul_comm, ‚Üê Real.norm_eq_abs, ‚Üê norm_smul]
            congr; field_simp; rw [smul_sub, smul_smul]; field_simp
          rw [Filter.tendsto_congr' this];
          have : Tendsto (fun (n : ‚Ñï) => c n ‚Ä¢ d n - v) atTop (ùìù (v - v)) := by
            apply Filter.Tendsto.sub vt2 tendsto_const_nhds
          apply Filter.Tendsto.norm at this
          simp at this; convert this; simp [hzd]
        ¬∑ apply Filter.Eventually.mp hcp
          apply Filter.Eventually.of_forall
          intro n hcn1 hcn2
          exfalso; simp at hcn2; linarith
      rw [Asymptotics.isLittleO_iff]; intro c1 hc1
      rw [Asymptotics.isLittleO_iff] at t5;
      have pos1 : ‚Äñgradient f loc‚Äñ ‚â† (0 : ‚Ñù) := by
        by_contra hhh; simp at hhh
        have : inner v (gradient f loc) = (0 : ‚Ñù) := by rw [hhh, inner_zero_right]
        linarith
      have pos2 : ‚Äñgradient f loc‚Äñ > (0 : ‚Ñù) := by positivity
      have : c1 / ‚Äñgradient f loc‚Äñ > (0 : ‚Ñù) := by positivity
      specialize t5 this
      apply Filter.Eventually.mp t5
      apply Filter.Eventually.of_forall
      intro n hn;
      calc _ ‚â§ ‚Äñz n - loc - (1 / c n) ‚Ä¢ v‚Äñ * ‚Äñgradient f loc‚Äñ := norm_inner_le_norm _ _
           _ ‚â§ c1 / ‚Äñgradient f loc‚Äñ * ‚Äñ1 / c n‚Äñ * ‚Äñgradient f loc‚Äñ :=
              (mul_le_mul_right pos2).mpr hn
           _ ‚â§ c1 * ‚Äñ1 / c n‚Äñ := by ring_nf; field_simp [pos1]
    have t4 :  (fun n => f (z n) - f loc - 1 / c n * Inner.inner v (gradient f loc)) =
        (fun n ‚Ü¶ f (z n) - f loc - inner (z n - loc) (gradient f loc)) +
        (fun n ‚Ü¶ (inner (z n - loc - (1 / c n) ‚Ä¢ v) (gradient f loc) : ‚Ñù)) := by
      ext n; dsimp; simp [inner_sub_left, inner_add_left, inner_smul_left]
    rw [t4]; apply Asymptotics.IsLittleO.add t2 t3
  have hz2 : ‚àÄ·∂† (n : ‚Ñï) in atTop, f (z n) ‚â§ f loc + (1 / 2) *
      (1 / c n) * inner v (gradient f loc) := by
    rw [Asymptotics.isLittleO_iff] at hz1
    have : (- (1 / 2 : ‚Ñù) * inner v (gradient f loc)) > 0 := by
      simp [proneg];rw [mul_comm]; apply mul_neg_of_neg_of_pos proneg (by norm_num)
    specialize hz1 this
    apply Filter.Eventually.mp hz1
    apply Filter.Eventually.mp hz3
    apply Filter.Eventually.of_forall
    intro n hn hn1
    rw [Real.norm_eq_abs, Real.norm_eq_abs, abs_le, abs_of_pos hn] at hn1
    rcases hn1 with ‚ü®_, hn1‚ü©
    rw [sub_le_iff_le_add, sub_le_iff_le_add] at hn1
    have : -(1 / 2) * inner v (gradient f loc) * (1 / c n) + 1 / c n * inner v
        (gradient f loc) + f loc = f loc + 1 / 2 * (1 / c n) * inner v (gradient f loc) := by
      ring_nf
    rw [this] at hn1; exact hn1
  have hz4 : ‚àÄ·∂† (n : ‚Ñï) in atTop, f (z n) < f loc := by
    apply Filter.Eventually.mp hz2
    apply Filter.Eventually.mp hz3
    apply Filter.Eventually.of_forall
    intro n hn1 hn2
    have : 1 / 2 * (1 / c n) * (inner v (gradient f loc)) < 0 := by
      apply mul_neg_of_pos_of_neg
      ¬∑ apply Right.mul_pos; simp; exact hn1
      ¬∑ exact proneg
    linarith
  have hz5 : ‚àÄ·∂† (n : ‚Ñï) in atTop, z n ‚àà s1 := by
    simp only [s1, mem_inter_iff, Metric.mem_ball, dist_self_add_left]
    apply Filter.Eventually.and
    ¬∑ rw [Filter.tendsto_atTop'] at hzt
      simp;
      have : Metric.ball loc Œµ ‚àà ùìù loc := by exact Metric.ball_mem_nhds loc Œµpos
      rcases hzt (Metric.ball loc Œµ) this with ‚ü®a, ha‚ü©
      use a; intro b hb; specialize ha b (by linarith [hb])
      simp at ha; exact ha
    ¬∑ simp; use a
  simp at hz5 hz4
  rcases hz5 with ‚ü®n, hn1‚ü©; rcases hz4 with ‚ü®m, hm1‚ü©
  let M := max n m
  have hh2 : f (z M) < f loc := hm1 M (le_max_right n m)
  have hh1 : z M ‚àà s1 := by simp [s1]; apply hn1 M (le_max_left n m)
  have hh3 : f loc ‚â§ f (z M) := hmin (z M) hh1
  linarith

/-
  Linearized feasible directions contain tagent cone
  Numerical Optimization, Nocedal & Wright, Lemma 12.2
-/
theorem linearized_feasible_directions_contain_tagent_cone (xf : x ‚àà p.FeasSet)
    (diffable : ‚àÄ i ‚àà œÑ, DifferentiableAt ‚Ñù (equality_constraints p i) x)
    (diffable‚ÇÇ : ‚àÄ i ‚àà œÉ, DifferentiableAt ‚Ñù (inequality_constraints p i) x) :
    posTangentConeAt p.FeasSet x ‚äÜ p.linearized_feasible_directions x := by
  intro v hv
  rw [linearized_feasible_directions]
  simp; constructor
  have imin : ‚àÄ i ‚àà œÑ, IsLocalMinOn (equality_constraints p i) p.FeasSet x := by
    intro i itau
    rw [IsLocalMinOn, IsMinFilter, Filter.eventually_iff_exists_mem]
    use p.FeasSet; constructor
    . use univ; constructor
      simp; use p.FeasSet; constructor
      simp; exact Eq.symm (univ_inter FeasSet)
    . intro y yf
      rw [FeasSet] at yf xf
      rw [(yf.2.1 i itau), (xf.2.1 i itau)]
  have negimin : ‚àÄ i ‚àà œÑ, IsLocalMinOn (-equality_constraints p i) p.FeasSet x := by
    intro i itau
    rw [IsLocalMinOn, IsMinFilter, Filter.eventually_iff_exists_mem]
    use p.FeasSet; constructor
    . use univ; constructor
      simp; use p.FeasSet; constructor
      simp; exact Eq.symm (univ_inter FeasSet)
    . intro y yf; simp
      rw [FeasSet] at yf xf
      rw [(yf.2.1 i itau), (xf.2.1 i itau)]
  . intro i itau
    apply ge_antisymm
    . apply posTangentCone_localmin_inner_pos (imin i itau) (diffable i itau) v hv
    . rw [‚Üê neg_neg (inner (gradient (equality_constraints p i) x) v)]
      apply neg_nonpos_of_nonneg
      rw [‚Üê inner_neg_left]
      have a‚ÇÅ : ‚àÄ i ‚àà œÑ, DifferentiableAt ‚Ñù (-equality_constraints p i) x :=
        fun i itau ‚Ü¶ DifferentiableAt.neg (diffable i itau)
      have a‚ÇÇ : - gradient (equality_constraints p i) x =
          gradient (-equality_constraints p i) x := by
        symm
        apply HasGradientAt.gradient
        apply HasGradientAt.neg
        exact DifferentiableAt.hasGradientAt (diffable i itau)
      rw [a‚ÇÇ]
      apply posTangentCone_localmin_inner_pos (negimin i itau) (a‚ÇÅ i itau) v hv
  . intro j hj jact
    rw [active_set] at jact; simp at jact
    rcases jact with jtau | jsigma
    . have := p.eq_ine_not_intersect
      rw [Finset.ext_iff] at this
      simp at this
      have jns : j ‚àâ œÉ := by apply this j jtau
      tauto
    . rcases jsigma with ‚ü®js, ineq‚ü©
      have jmin : ‚àÄ i ‚àà œÉ , (inequality_constraints p i x = 0) ‚Üí
          IsLocalMinOn (inequality_constraints p i) p.FeasSet x := by
        intro i is inezero
        rw [IsLocalMinOn, IsMinFilter, Filter.eventually_iff_exists_mem]
        use p.FeasSet; constructor
        . use univ; constructor
          simp; use p.FeasSet; constructor
          simp; exact Eq.symm (univ_inter FeasSet)
        . intro y yf
          rw [FeasSet] at yf xf
          rw [inezero]
          apply yf.2.2 i is
      apply posTangentCone_localmin_inner_pos (jmin j js ineq) (diffable‚ÇÇ j js) v hv

/-
  If x‚àó is a local solution of the constrained optimization problem,
  then we have ‚àá f (x‚àó) ^ T d ‚â• 0, for all d ‚àà T_Œ© (x‚àó).
  Numerical Optimization, Nocedal & Wright, Theorem 12.3
-/
theorem local_minima_TangentCone (loc : E) (hl : p.Local_Minima loc)
    (hf : Differentiable ‚Ñù p.objective) :
    ‚àÄ v ‚àà posTangentConeAt p.FeasSet loc, ‚ü™gradient p.objective loc, v‚ü´_‚Ñù ‚â• (0 : ‚Ñù) :=
  fun v vt ‚Ü¶ posTangentCone_localmin_inner_pos hl.2 (hf loc) v vt

theorem local_minima_TangentCone' (loc : E) (hl : p.Local_Minima loc)
    (hf : Differentiable ‚Ñù p.objective) :
    posTangentConeAt p.FeasSet loc ‚à© {d | ‚ü™gradient p.objective loc, d‚ü´_‚Ñù < (0 : ‚Ñù)} = ‚àÖ := by
  rw [Set.eq_empty_iff_forall_not_mem]
  intro d ‚ü®hd1, hd2‚ü©
  simp at hd2
  obtain hd1 := local_minima_TangentCone loc hl hf d hd1
  linarith

lemma contdiff_equiv {x : E} (c : E ‚Üí ‚Ñù) (hc : ContDiffAt ‚Ñù (1 : ‚Ñï) c x) :
    ‚àÉ (c' : E ‚Üí E), (‚àÄ·∂† y in ùìù x, HasGradientAt c (c' y) y) ‚àß ContinuousAt c' x := by
  have aux := @contDiffAt_succ_iff_hasFDerivAt ‚Ñù _ _ _ _ _ _ _ c x 0
  simp at aux; simp at hc; rw [aux] at hc
  rcases hc with ‚ü®f', ‚ü®hf1, hf2‚ü©‚ü©
  let g := fun z ‚Ü¶ (toDual ‚Ñù E).symm (f' z)
  use g; constructor
  ¬∑ rw [Filter.eventually_iff_exists_mem]; rcases hf1 with ‚ü®u, ‚ü®hu1, hu2‚ü©‚ü©
    use u; constructor; exact hu1
    intro x hu; specialize hu2 x hu
    simp [g]; exact hasFDerivAt_iff_hasGradientAt.mp hu2
  simp [g];
  have hf2 := ContDiffAt.continuousAt hf2
  apply ContinuousAt.comp
  ¬∑ exact LinearIsometryEquiv.continuousAt (toDual ‚Ñù E).symm
  assumption

lemma diffable_of_hasgradient_nhds {x : E} {Œº : Finset ‚Ñï}
    {c : (i : ‚Ñï) ‚Üí E ‚Üí ‚Ñù} (gradci : ‚àÄ i ‚àà Œº, ContDiffAt ‚Ñù 1 (c i) x) :
    ‚àÄ i ‚àà Œº, DifferentiableAt ‚Ñù (c i) x := by
  intro i iin; specialize gradci i iin
  rcases (contdiff_equiv (c i) gradci) with ‚ü®c', ‚ü®gradci, _‚ü©‚ü©
  rw [eventually_iff, Metric.mem_nhds_iff] at gradci
  rcases gradci with ‚ü®Œµ, Œµpos, hasgrad‚ü©
  have : x ‚àà Metric.ball x Œµ := by simp [Œµpos]
  obtain hx := Set.mem_of_subset_of_mem hasgrad this; simp at hx
  apply HasGradientAt.differentiableAt hx

lemma LICQ_inactive_nhds (x : E) (xf : x ‚àà p.FeasSet)
    (gradci : ‚àÄ i ‚àà œÉ, ContDiffAt ‚Ñù 1 (inequality_constraints p i) x) :
  ‚àÉ Œµ > 0, ‚àÄ i ‚àà œÉ \ (p.active_set x), ‚àÄ z ‚àà Metric.ball x Œµ, 0 < p.inequality_constraints i z := by
  have diffable : ‚àÄ i ‚àà œÉ, DifferentiableAt ‚Ñù (inequality_constraints p i) x :=
    diffable_of_hasgradient_nhds gradci
  have inactive : ‚àÄ i ‚àà œÉ \ (p.active_set x), 0 < p.inequality_constraints i x := by
    intro i iin; simp at iin
    simp [FeasSet, FeasPoint] at xf
    obtain nneg := xf.2.2 i iin.1
    obtain inin := iin.2; simp [active_set] at inin
    obtain nzero := inin.2; simp [iin] at nzero
    apply lt_of_le_of_ne nneg; symm; simp [nzero]
  have inactive_Œµ : ‚àÄ i ‚àà œÉ \ (p.active_set x), ‚àÄ·∂† (z : E) in ùìù x,
      0 < p.inequality_constraints i z := by
    intro i iin; specialize inactive i iin; simp at iin; specialize diffable i iin.1
    rw [eventually_iff, Metric.mem_nhds_iff]
    obtain hc := ContinuousAt_Convergence (DifferentiableAt.continuousAt diffable)
    let Œµ := (p.inequality_constraints i x) / 2
    have Œµpos : 0 < Œµ := by simp [Œµ]; linarith [inactive]
    obtain ‚ü®Œ¥, Œ¥pos, hc‚ü© := hc Œµ Œµpos
    use Œ¥; use Œ¥pos
    intro z zin; simp at zin; rw [dist_eq_norm, norm_sub_rev] at zin
    specialize hc z (LT.lt.le zin); simp [Œµ] at hc
    obtain ieq := sub_le_of_abs_sub_le_left hc
    calc
      0 < p.inequality_constraints i x - p.inequality_constraints i x / 2 := by linarith [inactive]
      _ ‚â§ p.inequality_constraints i z := ieq
  rw [‚Üê Finset.eventually_all, eventually_iff, Metric.mem_nhds_iff] at inactive_Œµ
  rcases inactive_Œµ with ‚ü®Œµ, Œµpos, sub‚ü©
  use Œµ; use Œµpos; intro i iin z zin; simp at iin
  obtain hz := Set.mem_of_subset_of_mem sub zin; simp at hz
  specialize hz i; simp [iin] at hz; exact hz

private lemma smul_div_right_eq_left_smul {a c : E} {b : ‚Ñï} (h‚ÇÅ : b ‚â† 0) :
    a = (1 / (b : ‚Ñù)) ‚Ä¢ c ‚Üî (b : ‚Ñù) ‚Ä¢ a = c := by
  constructor
  ¬∑ intro h; rw [h]; rw [smul_smul]; field_simp
  intro h; rw [‚Üê h]; rw [smul_smul]; field_simp

lemma contdiff_hasgradientat (x : E) (c : E ‚Üí ‚Ñù) (hc : ContDiffAt ‚Ñù 1 c x) :
    ‚àÄ·∂† y in ùìù x, HasGradientAt c (gradient c y) y := by
  rcases contdiff_equiv c hc with ‚ü®c', ‚ü®hc1, _‚ü©‚ü©
  apply Filter.Eventually.mono hc1
  intro x hx; obtain hx := HasGradientAt.differentiableAt hx
  exact hx.hasGradientAt

lemma LICQ_nhds_grad (x : E)
    (conte : ‚àÄ i ‚àà œÑ, ContDiffAt ‚Ñù 1 (equality_constraints p i) x)
    (conti : ‚àÄ i ‚àà œÉ, ContDiffAt ‚Ñù 1 (inequality_constraints p i) x) :
    ‚àÄ·∂† y in ùìù x,
    (‚àÄ i ‚àà œÑ, HasGradientAt (equality_constraints p i)
      (gradient (equality_constraints p i) y) y) ‚àß
    (‚àÄ i ‚àà œÉ, HasGradientAt (inequality_constraints p i)
      (gradient (inequality_constraints p i) y) y) := by
  have conte : ‚àÄ i ‚àà œÑ, ‚àÄ·∂† y in ùìù x, HasGradientAt (equality_constraints p i)
      (gradient (equality_constraints p i) y) y :=
    fun i hi ‚Ü¶ contdiff_hasgradientat x (equality_constraints p i) (conte i hi)
  have conti : ‚àÄ i ‚àà œÉ, ‚àÄ·∂† y in ùìù x, HasGradientAt (inequality_constraints p i)
      (gradient (inequality_constraints p i) y) y :=
    fun i hi ‚Ü¶ contdiff_hasgradientat x (inequality_constraints p i) (conti i hi)
  rw [‚Üê Finset.eventually_all] at conte; rw [‚Üê Finset.eventually_all] at conti
  rw [Filter.eventually_and]; exact ‚ü®conte, conti‚ü©

lemma StrictFderivAt_of_FderivAt_of_ContinuousAt
    {x : E} {c : E ‚Üí ‚Ñù} (hcd : ContDiffAt ‚Ñù (1 : ‚Ñï) c x) : (fun p_1 : E √ó E ‚Ü¶
    c p_1.1 - c p_1.2 - ‚ü™gradient c x, p_1.1 - p_1.2‚ü´_‚Ñù) =o[ùìù (x, x)] fun p ‚Ü¶ p.1 - p.2 := by
  rcases (contdiff_equiv c hcd) with ‚ü®c', ‚ü®hgrad, hcont‚ü©‚ü©
  refine Asymptotics.isLittleO_iff.mpr fun Œº hŒº => Metric.eventually_nhds_iff_ball.mpr ?_
  rcases Metric.mem_nhds_iff.mp (inter_mem hgrad (hcont <| Metric.ball_mem_nhds _ hŒº))
    with ‚ü®Œµ, Œµ0, hŒµ‚ü©
  refine ‚ü®Œµ, Œµ0, ?_‚ü©
  rintro ‚ü®a, b‚ü© h
  rw [‚Üê ball_prod_same, prod_mk_mem_set_prod_eq] at h
  have hf' : ‚àÄ x' ‚àà Metric.ball x Œµ, ‚Äñc' x' - c' x‚Äñ ‚â§ Œº := fun x' H' => by
    rw [‚Üê dist_eq_norm]
    exact le_of_lt (hŒµ H').2
  obtain h1 := convex_ball x Œµ
  have h2 : ‚àÄ y ‚àà Metric.ball x Œµ, HasGradientAt c (c' y) y := fun _ yin ‚Ü¶ (hŒµ yin).1
  obtain ‚ü®Œ±, Œ±in, eq‚ü© := lagrange h1 h2 b h.2 a h.1
  obtain mem := Convex.add_smul_sub_mem h1 h.2 h.1 (Set.Ioo_subset_Icc_self Œ±in)
  specialize hf' (b + Œ± ‚Ä¢ (a - b)) mem
  rw [‚Üê eq, ‚Üê inner_sub_left];
  have : gradient c x = c' x := by
    refine HasGradientAt.gradient ?h; exact h2 x (Metric.mem_ball_self Œµ0)
  rw [this]
  calc
    _ ‚â§ ‚Äñc' (b + Œ± ‚Ä¢ (a - b)) - c' x‚Äñ * ‚Äñ(a, b).1 - (a, b).2‚Äñ := by apply norm_inner_le_norm
    _ ‚â§ Œº * ‚Äñ(a, b).1 - (a, b).2‚Äñ := by apply mul_le_mul_of_nonneg_right hf' (norm_nonneg (a - b))

end Constrained_OptimizationProblem_property_general

section Constrained_OptimizationProblem_property_finite_dimensional

open Constrained_OptimizationProblem Topology InnerProductSpace Set Filter Tendsto Matrix

variable {n : ‚Ñï} {x : EuclideanSpace ‚Ñù (Fin n)}
variable {œÑ œÉ : Finset ‚Ñï} {p : Constrained_OptimizationProblem (EuclideanSpace ‚Ñù (Fin n)) œÑ œÉ}
variable {M : Matrix (p.active_set x) (Fin n) ‚Ñù} {v : EuclideanSpace ‚Ñù (Fin n)}

lemma LICQ_mlen (x : EuclideanSpace ‚Ñù (Fin n)) (LIx : p.LICQ x)
    {m : ‚Ñï} (meq : m = (p.active_set x).card) : m ‚â§ n := by
  let cond := LinearIndependent.fintype_card_le_finrank LIx
  simp at cond; rw [meq]; simp; exact cond

lemma LICQ_Axfullrank (x : EuclideanSpace ‚Ñù (Fin n)) (LIx : p.LICQ x)
    {M : Matrix (p.active_set x) (Fin n) ‚Ñù}
    (eq : M = fun i : (p.active_set x) ‚Ü¶ if i.1 ‚àà œÑ then gradient (p.equality_constraints i) x
        else gradient (p.inequality_constraints i) x):
    Matrix.rank M = (Fintype.card (p.active_set x)) := by
  apply LE.le.antisymm
  ¬∑ apply Matrix.rank_le_card_height
  ¬∑ simp
    rw [Matrix.rank_eq_finrank_span_row, finrank_span_eq_card]
    simp; rw [eq]; apply LIx

lemma LICQ_existZ (x : EuclideanSpace ‚Ñù (Fin n)) (LIx : p.LICQ x)
    {m : ‚Ñï} (meq : m = (p.active_set x).card)
    {M : Matrix (p.active_set x) (Fin n) ‚Ñù}
    (eq : M = fun i : (p.active_set x) ‚Ü¶ if i.1 ‚àà œÑ then gradient (p.equality_constraints i) x
        else gradient (p.inequality_constraints i) x):
    ‚àÉ (Z : Matrix (Fin n) (Fin (n - m)) ‚Ñù), M * Z = 0 ‚àß Matrix.rank Z = (n - m) := by
  rw [LICQ] at LIx;
  have mlen : m ‚â§ n := LICQ_mlen x LIx meq
  have fullrowrank : Matrix.rank M = (Fintype.card (p.active_set x)) := LICQ_Axfullrank x LIx eq
  let map := Matrix.toLin' M
  let eq := LinearMap.finrank_range_add_finrank_ker map
  simp [map] at eq
  have aux : FiniteDimensional.finrank ‚Ñù (LinearMap.range (Matrix.toLin' M)) = m := by
    rw [Matrix.range_toLin', ‚Üê Matrix.rank_eq_finrank_span_cols, fullrowrank]; simp [meq]
  rw [aux] at eq
  let kernel := LinearMap.ker (Matrix.toLin' M)
  have dim_ker : FiniteDimensional.finrank ‚Ñù kernel = n - m := by
    simp [kernel]; rw [Nat.sub_eq_of_eq_add]; linarith [eq]
  let base := FiniteDimensional.finBasis ‚Ñù kernel
  rw [dim_ker] at base
  let Z : Matrix (Fin (n - m)) (Fin n) ‚Ñù := fun i ‚Ü¶ base i
  use Z·µÄ
  constructor
  ¬∑ have colzero : ‚àÄ i : (Fin (n - m)), (Z * M·µÄ) i = 0 := by
      intro i
      rw [Matrix.mul_apply_eq_vecMul, ‚Üê Matrix.mulVec_transpose, Matrix.transpose_transpose]
      have zinker : (Z i) ‚àà kernel := by simp [Z]
      simp only [kernel] at zinker; rw [LinearMap.mem_ker, Matrix.toLin'] at zinker
      simp at zinker; exact zinker
    rw [‚Üê Matrix.transpose_eq_zero]; simp
    ext i j; rw [colzero i]; simp
  ¬∑ rw [Matrix.rank_transpose]
    apply LE.le.antisymm
    ¬∑ apply Matrix.rank_le_height
    ¬∑ simp
      rw [Matrix.rank_eq_finrank_span_row, finrank_span_eq_card]
      simp; rw [Nat.sub_add_cancel]; apply mlen
      let base_indep := Basis.linearIndependent base
      simp only [Z]
      rw [linearIndependent_iff'']
      intro s g cond sum
      rw [linearIndependent_iff''] at base_indep
      specialize base_indep s g cond; apply base_indep
      let coe := @Subtype.val (Fin n ‚Üí ‚Ñù) (fun x ‚Ü¶ x ‚àà ‚Üëkernel)
      have coe_zero (x : kernel) : x = 0 ‚Üî coe x = 0 := by
        constructor
        ¬∑ intro cond; rw [cond]; simp [coe]
        ¬∑ intro cond; simp [coe] at cond; exact cond
      rw [coe_zero]; simp only [coe]
      rw [‚Üê sum]; simp

lemma mulVec_eq_toEuclidean {s : Type*} (M : Matrix s (Fin n) ‚Ñù) (y : EuclideanSpace ‚Ñù (Fin n)) :
    M *·µ• y = (toEuclideanLin M) y := by
  rw [Matrix.toEuclideanLin_apply]; ext j; simp [Matrix.mulVec, Matrix.dotProduct]

lemma inj_iff_full_finrank {s t : Type*} {M : Matrix s t ‚Ñù} [Fintype s] [Fintype t]
    (hn : Fintype.card s = Fintype.card t) :
    M.rank = Fintype.card s ‚Üî ‚àÄ (v : t ‚Üí ‚Ñù), M *·µ• v = 0 ‚Üí v = 0 := by
  rw [‚Üê ker_mulVecLin_eq_bot_iff, LinearMap.ker_eq_bot_iff_range_eq_top_of_finrank_eq_finrank,
      range_mulVecLin, rank_eq_finrank_span_cols]
  ¬∑ constructor
    ¬∑ intro hM; apply Submodule.eq_top_of_finrank_eq; simp; exact hM
    ¬∑ intro h; rw [h]; simp
  ¬∑ simp; rw [hn]

lemma inj_transpose_iff_inj_of_sq {s t : Type*} {M : Matrix s t ‚Ñù} [Fintype s] [Fintype t]
    (hn : Fintype.card s = Fintype.card t) :
    (‚àÄ (v : s ‚Üí ‚Ñù), M·µÄ *·µ• v = 0 ‚Üí v = 0) ‚Üî (‚àÄ (v : t ‚Üí ‚Ñù), M *·µ• v = 0 ‚Üí v = 0) := by
  rw [‚Üê inj_iff_full_finrank hn, ‚Üê inj_iff_full_finrank (symm hn), hn]; simp

lemma LICQ_injM (z : EuclideanSpace ‚Ñù (Fin n)) (m : ‚Ñï)
    (Z : Matrix (Fin n) (Fin (n - m)) ‚Ñù) (A : Matrix (p.active_set x) (Fin n) ‚Ñù)
    (meq : m = (p.active_set x).card) (mlen : m ‚â§ n)
    (Afull : Matrix.rank A = m) (Zfull : Matrix.rank Z = (n - m))
    (AZorth : A * Z = 0) :
    A *·µ• z = 0 ‚àß Z·µÄ *·µ• z = 0 ‚Üí z = 0 := by
  rintro ‚ü®eq1, eq2‚ü©
  let B : Matrix ((p.active_set x) ‚äï (Fin (n - m))) (Fin n) ‚Ñù :=
    Matrix.of (Sum.elim (fun (i : (p.active_set x)) => A i) fun (i : Fin (n - m)) => Z·µÄ i)
  let Bt : Matrix (Fin n) ((p.active_set x) ‚äï (Fin (n - m))) ‚Ñù :=
    Matrix.of (fun i => Sum.elim (A·µÄ i) (Z i))
  have Bteq : Bt = B·µÄ := by ext i j; simp [Bt, B]; cases j <;> simp
  have Bzeq0 : B *·µ• z = Sum.elim (A *·µ• z) (Z·µÄ *·µ• z) := by
    ext i; cases i <;> simp [B, mulVec, dotProduct]
  rw [eq1, eq2] at Bzeq0; simp at Bzeq0
  have aux : (p.active_set x).card + (n - m) = n := by
    rw [‚Üê meq]; rw [add_comm, Nat.sub_add_cancel]; exact mlen
  refine (inj_transpose_iff_inj_of_sq ?_).1 ?_ z Bzeq0
  ¬∑ simp; rw [aux]
  ¬∑ intro v Btveq0
    let y := v ‚àò Sum.inl
    let z := v ‚àò Sum.inr
    have yeq : Bt *·µ• (Sum.elim y (fun _ ‚Ü¶ 0)) = A·µÄ *·µ• y := by ext i; simp [Bt, mulVec, dotProduct]
    have zeq : Bt *·µ• (Sum.elim (fun _ ‚Ü¶ 0) z) = Z *·µ• z := by ext i; simp [Bt, mulVec, dotProduct]
    have veq : v = (Sum.elim y (fun _ ‚Ü¶ 0)) + (Sum.elim (fun _ ‚Ü¶ 0) z) := by
      simp [y, z]; ext i; cases i <;> simp
    have eq : B·µÄ *·µ• v = A·µÄ *·µ• y + Z *·µ• z := by rw [veq, ‚Üê Bteq, mulVec_add, yeq, zeq]
    rw [eq] at Btveq0
    have yzero : y = 0 := by
      have h : A *·µ• (A·µÄ *·µ• y + Z *·µ• z) = 0 := by rw [Btveq0]; simp
      rw [mulVec_add, mulVec_mulVec, mulVec_mulVec, AZorth] at h; simp at h
      refine (inj_iff_full_finrank ?_).1 ?_ y h
      ¬∑ simp
      ¬∑ simp; rw [‚Üê meq, Afull]
    have yzero' : (Sum.elim y (fun _ : (Fin (n - m)) ‚Ü¶ 0)) = 0 := by
      ext i; cases i <;> simp [yzero]
    have zzero : z = 0 := by
      have h : Z·µÄ *·µ• (A·µÄ *·µ• y + Z *·µ• z) = 0 := by rw [Btveq0]; simp
      rw [mulVec_add, mulVec_mulVec, mulVec_mulVec, ‚Üê transpose_mul, AZorth] at h; simp at h
      refine (inj_iff_full_finrank ?_).1 ?_ z h
      ¬∑ simp
      ¬∑ simp; rw [rank_transpose_mul_self, Zfull]
    have zzero' : (Sum.elim (fun _ : (p.active_set x) ‚Ü¶ 0) z) = 0 := by
      ext i; cases i <;> simp [zzero]
    rw [veq, yzero', zzero']; simp

lemma LICQ_strictfderiv_Ax_elem {x : EuclideanSpace ‚Ñù (Fin n)}
    (c : EuclideanSpace ‚Ñù (Fin n) ‚Üí ((p.active_set x) ‚Üí ‚Ñù))
    (ceq : c = fun z ‚Ü¶ (fun i : (p.active_set x) ‚Ü¶ if i.1 ‚àà œÑ then (p.equality_constraints i) z
      else (p.inequality_constraints i) z))
    (gradc : EuclideanSpace ‚Ñù (Fin n) ‚Üí ((p.active_set x) ‚Üí (EuclideanSpace ‚Ñù (Fin n))))
    (gradceq : gradc = fun z ‚Ü¶ (fun i : (p.active_set x) ‚Ü¶ if i.1 ‚àà œÑ then
      gradient (p.equality_constraints i) z else gradient (p.inequality_constraints i) z))
    (A : EuclideanSpace ‚Ñù (Fin n) ‚Üí Matrix (p.active_set x) (Fin n) ‚Ñù)
    (Aeq : A = fun z ‚Ü¶ (fun i ‚Ü¶ gradc z i))
    (Jz : EuclideanSpace ‚Ñù (Fin n) ‚Üí EuclideanSpace ‚Ñù (Fin n) ‚ÜíL[‚Ñù] EuclideanSpace ‚Ñù (p.active_set x))
    (Jzeq : Jz = fun z ‚Ü¶ (LinearMap.toContinuousLinearMap (toEuclideanLin (A z))))
    (conte : ‚àÄ i ‚àà œÑ, ContDiffAt ‚Ñù (1 : ‚Ñï) (equality_constraints p i) x)
    (conti : ‚àÄ i ‚àà œÉ, ContDiffAt ‚Ñù (1 : ‚Ñï) (inequality_constraints p i) x) :
    ‚àÄ (i : { x_1 // x_1 ‚àà active_set x }),
    HasStrictFDerivAt (fun x ‚Ü¶ c x i) ((EuclideanSpace.proj i).comp (Jz x)) x := by
  obtain h := LICQ_nhds_grad x conte conti
  rw [eventually_iff, Metric.mem_nhds_iff] at h; rcases h with ‚ü®Œµ, _, _‚ü©
  intro i; by_cases hi : i.1 ‚àà œÑ
  ¬∑ rw [ceq, Jzeq, Aeq]; simp [hi]
    rw [HasStrictFDerivAt];
    have eq : (fun p_1 : EuclideanSpace ‚Ñù (Fin n) √ó EuclideanSpace ‚Ñù (Fin n) ‚Ü¶
        p.equality_constraints i.1 p_1.1 - p.equality_constraints i.1 p_1.2 -
        ((EuclideanSpace.proj i).comp (LinearMap.toContinuousLinearMap (toEuclideanLin fun i ‚Ü¶ gradc x i)))
        (p_1.1 - p_1.2)) = (fun p_1 : EuclideanSpace ‚Ñù (Fin n) √ó EuclideanSpace ‚Ñù (Fin n) ‚Ü¶
        p.equality_constraints i.1 p_1.1 - p.equality_constraints i.1 p_1.2 -
        ‚ü™gradient (p.equality_constraints ‚Üëi) x, p_1.1 - p_1.2‚ü´_‚Ñù ):= by
      ext q; rw [inner_sub_right, gradceq]; simp [toEuclideanLin_apply, mulVec, dotProduct, hi]
    rw [eq]
    specialize conte i hi
    exact StrictFderivAt_of_FderivAt_of_ContinuousAt conte
  ¬∑ have hi' : i.1 ‚àà œÉ := by
      obtain h := i.2; simp [active_set, hi] at h; exact h.1
    rw [ceq, Jzeq, Aeq]; simp [hi]
    rw [HasStrictFDerivAt];
    have eq : (fun p_1 : EuclideanSpace ‚Ñù (Fin n) √ó EuclideanSpace ‚Ñù (Fin n) ‚Ü¶
        p.inequality_constraints i.1 p_1.1 - p.inequality_constraints i.1 p_1.2 -
        ((EuclideanSpace.proj i).comp (LinearMap.toContinuousLinearMap (toEuclideanLin fun i ‚Ü¶ gradc x i)))
        (p_1.1 - p_1.2)) = (fun p_1 : EuclideanSpace ‚Ñù (Fin n) √ó EuclideanSpace ‚Ñù (Fin n) ‚Ü¶
        p.inequality_constraints i.1 p_1.1 - p.inequality_constraints i.1 p_1.2 -
        ‚ü™gradient (p.inequality_constraints ‚Üëi) x, p_1.1 - p_1.2‚ü´_‚Ñù ):= by
      ext q; rw [inner_sub_right, gradceq]; simp [toEuclideanLin_apply, mulVec, dotProduct, hi]
    rw [eq]
    specialize conti i hi'
    exact StrictFderivAt_of_FderivAt_of_ContinuousAt conti

lemma LICQ_implicit_f {x : EuclideanSpace ‚Ñù (Fin n)} {m : ‚Ñï} (v : EuclideanSpace ‚Ñù (Fin n))
    {Mx : EuclideanSpace ‚Ñù (Fin n) ‚ÜíL[‚Ñù] EuclideanSpace ‚Ñù (p.active_set x) √ó (Fin (n - m) ‚Üí ‚Ñù)}
    {Rz : EuclideanSpace ‚Ñù (Fin n) ‚Üí EuclideanSpace ‚Ñù (p.active_set x) √ó (Fin (n - m) ‚Üí ‚Ñù)}
    {Rt : ‚Ñù ‚Üí EuclideanSpace ‚Ñù (p.active_set x) √ó (Fin (n - m) ‚Üí ‚Ñù)}
    (Rteq : Rt = fun t ‚Ü¶ t ‚Ä¢ Mx v) (Rxeq0 : Rz x = 0)
    (Rzgrad : HasStrictFDerivAt Rz Mx x) (Mxsurj : LinearMap.range Mx = ‚ä§) :
    ‚àÉ (N : ‚Ñï) (d : ‚Ñï ‚Üí EuclideanSpace ‚Ñù (Fin n)), (‚àÄ m ‚â• N, Rz (d m) = Rt (1 / m)) ‚àß
      (Filter.Tendsto d atTop (ùìù x)) := by
  let g := HasStrictFDerivAt.implicitFunction Rz Mx Rzgrad Mxsurj
  have hfg : ‚àÄ·∂† (p : (EuclideanSpace ‚Ñù (p.active_set x) √ó (Fin (n - m) ‚Üí ‚Ñù)) √ó (LinearMap.ker Mx)) in
      ùìù (Rz x, (0 : LinearMap.ker Mx)), Rz (g p.1 p.2) = p.1 := by
    simp only [g]; apply HasStrictFDerivAt.map_implicitFunction_eq Rzgrad Mxsurj
  rw [Rxeq0] at hfg
  rw [eventually_iff, Metric.mem_nhds_iff] at hfg
  rcases hfg with ‚ü®Œµ, Œµpos, nhdsin‚ü©
  have RtleŒµ : ‚àÄ Œµ > 0, ‚àÉ N : ‚Ñï, ‚àÄ m ‚â• N, ‚ÄñRt (m)‚Åª¬π‚Äñ < Œµ := by
    intro Œµ Œµpos
    rw [Rteq]; simp [norm_smul]
    obtain ‚ü®N, Ngt‚ü© := exists_nat_gt (‚ÄñMx v‚Äñ / Œµ); use N
    intro m mgeN; field_simp
    have mgt : ‚ÄñMx v‚Äñ / Œµ < m := by apply LT.lt.trans_le Ngt; simp [mgeN]
    have mpos : (0 : ‚Ñù) < m := by
      apply LT.lt.trans_le' mgt; apply div_nonneg; apply norm_nonneg; linarith
    rw [div_lt_comm‚ÇÄ mpos Œµpos]; exact mgt
  obtain ‚ü®N, Rtle‚ü© := RtleŒµ Œµ Œµpos
  use N; use fun n ‚Ü¶ g (Rt (1 / n)) 0; constructor
  ¬∑ intro m mgeN; specialize Rtle m mgeN
    have Rtmin : (Rt (1 / m), 0) ‚àà {x_1 | Rz (g x_1.1 x_1.2) = x_1.1} := by
      apply Set.mem_of_subset_of_mem nhdsin; simp only [one_div, Metric.mem_ball,
        dist_prod_same_right, dist_zero_right]; apply Rtle
    simp at Rtmin; simp [Rtmin]
  ¬∑ simp only [g]
    apply HasStrictFDerivAt.tendsto_implicitFunction Rzgrad Mxsurj
    ¬∑ rw [Rxeq0]; rw [NormedAddCommGroup.tendsto_nhds_zero]; simp; apply RtleŒµ
    ¬∑ simp

lemma eq_lemma {y z : EuclideanSpace ‚Ñù (Fin n)} {n : ‚Ñï} (h : ‚Äñ(n : ‚Ñù) ‚Ä¢ y‚Äñ ‚â† 0) :
    (1 / ‚Äñy‚Äñ) ‚Ä¢ (y - (1 / (n : ‚Ñù)) ‚Ä¢ z) = (1 / ‚Äñ(n : ‚Ñù) ‚Ä¢ y‚Äñ) ‚Ä¢ ((n : ‚Ñù) ‚Ä¢ y - z) := by
  rw [norm_smul] at h; simp at h
  have eq : z = (n : ‚Ñù) ‚Ä¢ (1 / n : ‚Ñù) ‚Ä¢ z := by
    rw [smul_smul]; field_simp; rw [div_self, one_smul]; simp [h]
  nth_rw 2 [eq]
  rw [‚Üê smul_sub, smul_smul, norm_smul]; field_simp; rw [‚Üê div_div, div_self]; simp [h]

lemma comap1 {x : EuclideanSpace ‚Ñù (Fin n)} {m : ‚Ñï}
    {Mx : EuclideanSpace ‚Ñù (Fin n) ‚ÜíL[‚Ñù] EuclideanSpace ‚Ñù (p.active_set x) √ó (Fin (n - m) ‚Üí ‚Ñù)}
    (v : EuclideanSpace ‚Ñù (Fin n)) (vne0 : v ‚â† 0)
    (Mxbij : Function.Bijective Mx) : comap (fun z ‚Ü¶ ‚ÄñMx z‚Äñ) (ùìù 0) ‚â§ ùìù 0 := by
  rw [ContinuousLinearMap.bijective_iff_dense_range_and_antilipschitz] at Mxbij
  obtain ‚ü®c, antil‚ü© := Mxbij.2
  rw [Filter.le_def]; intro s smem
  rw [Metric.mem_nhds_iff] at smem; rcases smem with ‚ü®a, apos, ha‚ü©
  rw [antilipschitzWith_iff_le_mul_dist] at antil
  have hc : 0 ‚â† c := by
    symm; by_contra hc
    specialize antil 0; simp [hc] at antil; specialize antil v
    absurd antil; simp [vne0]
  have hc' : 0 < c := by refine lt_of_le_of_ne ?_ hc; simp
  use Metric.ball 0 (a / c); constructor
  ¬∑ apply Metric.ball_mem_nhds
    refine div_pos ?_ hc' ; linarith [apos]
  ¬∑ intro z zin; simp at zin
    specialize antil 0 z; simp at antil
    have zin' : z ‚àà Metric.ball 0 a := by
      simp; calc
        ‚Äñz‚Äñ ‚â§ c * ‚ÄñMx z‚Äñ := antil
        _ < c * (a / c) := by rw [mul_lt_mul_left]; linarith [zin]; simp [hc']
        _ = a := by field_simp
    exact ha zin'

lemma comap2 (hv : v ‚â† 0):
    comap (fun z : EuclideanSpace ‚Ñù (Fin n) ‚Ü¶ if (‚Äñz‚Äñ = 0) then v else ‚Äñz‚Äñ‚Åª¬π ‚Ä¢ (z - v))
    (ùìù 0) ‚â§ ùìù v := by
  rw [Filter.le_def]; intro s smem; simp
  rw [Metric.mem_nhds_iff] at smem; rcases smem with ‚ü®a, apos, ha‚ü©
  let Œº := a / (a + ‚Äñv‚Äñ)
  have eq : Œº * ‚Äñv‚Äñ = (1 - Œº) * a := by
    field_simp [Œº]; rw [mul_comm]
  have vpos : 0 < ‚Äñv‚Äñ := by
    refine lt_of_le_of_ne (norm_nonneg v) ?_; symm; simp [hv]
  have Œºle : 0 < 1 - Œº := by
    field_simp [Œº, hv]
    apply add_pos ?_ vpos; linarith
  have Œºpos : 0 < Œº := by
    field_simp [Œº]; apply add_pos_of_pos_of_nonneg _ (norm_nonneg v); linarith
  let r := min Œº ‚Äñv‚Äñ
  use Metric.ball 0 r; constructor
  ¬∑ apply Metric.ball_mem_nhds; simp [r]; exact ‚ü®Œºpos, hv‚ü©
  ¬∑ intro z zin; simp at zin;
    have ze : z ‚â† 0 := by
      by_contra hz; simp [hz] at zin; simp [r] at zin
    simp [ze] at zin; rw [norm_smul] at zin; field_simp at zin
    have : 0 < ‚Äñz‚Äñ := by refine lt_of_le_of_ne (norm_nonneg z) ?_; symm; simp [ze]
    rw [div_lt_iff this] at zin
    have ieq : ‚Äñz - v‚Äñ < Œº * ‚Äñz - v‚Äñ + (1 - Œº) * a := by
      calc
        _ < r * ‚Äñz‚Äñ := zin
        _ ‚â§ Œº * ‚Äñz‚Äñ := by rw [mul_le_mul_right this]; simp [r]
        _ ‚â§ Œº * (‚Äñz - v‚Äñ + ‚Äñv‚Äñ) := by
          rw [mul_le_mul_left Œºpos, add_comm]; apply norm_le_norm_add_norm_sub'
        _ ‚â§ Œº * ‚Äñz - v‚Äñ + (1 - Œº) * a := by rw [mul_add]; apply add_le_add_left; rw [eq]
    rw [‚Üê sub_lt_iff_lt_add'] at ieq; nth_rw 1 [‚Üê one_mul (‚Äñz - v‚Äñ)] at ieq
    rw [‚Üê sub_mul, mul_lt_mul_left Œºle] at ieq
    apply ha; simp; rw [dist_eq_norm]; simp [ieq]

lemma LICQ_tendsto {x : EuclideanSpace ‚Ñù (Fin n)} {m N : ‚Ñï}
    {Mx : EuclideanSpace ‚Ñù (Fin n) ‚ÜíL[‚Ñù] EuclideanSpace ‚Ñù (p.active_set x) √ó (Fin (n - m) ‚Üí ‚Ñù)}
    {Rz : EuclideanSpace ‚Ñù (Fin n) ‚Üí EuclideanSpace ‚Ñù (p.active_set x) √ó (Fin (n - m) ‚Üí ‚Ñù)}
    {Rt : ‚Ñù ‚Üí EuclideanSpace ‚Ñù (p.active_set x) √ó (Fin (n - m) ‚Üí ‚Ñù)}
    {d : ‚Ñï ‚Üí EuclideanSpace ‚Ñù (Fin n)}
    (v : EuclideanSpace ‚Ñù (Fin n)) (vne0 : v ‚â† 0)
    (Rteq : Rt = fun t ‚Ü¶ t ‚Ä¢ Mx v) (Rxeq0 : Rz x = 0)
    (hfd : ‚àÄ i ‚â• N, Rz (d i) = Rt (1 / (i : ‚Ñù)))
    (dtend : ‚àÄ (Œµ : ‚Ñù), 0 < Œµ ‚Üí ‚àÉ a, ‚àÄ (b : ‚Ñï), a ‚â§ b ‚Üí ‚Äñd b - x‚Äñ < Œµ)
    (Mxbij : Function.Bijective Mx)
    (deriv : Tendsto ((fun x' ‚Ü¶ ‚Äñx' - x‚Äñ‚Åª¬π * ‚ÄñRz x' - Rz x - Mx (x' - x)‚Äñ) ‚àò d) atTop (ùìù 0)) :
    Tendsto (fun i : ‚Ñï ‚Ü¶ (i : ‚Ñù) ‚Ä¢ (d i - x)) atTop (ùìù v) := by
  have dne : ‚àÄ i ‚â• N.succ, d i ‚â† x := by
    contrapose! hfd; rcases hfd with ‚ü®i, igeN, dieq‚ü©; simp at igeN
    use i; constructor
    ¬∑ simp; linarith [igeN]
    ¬∑ rw [dieq, Rxeq0, Rteq]; symm; rw [smul_ne_zero_iff]; simp; constructor
      ¬∑ linarith [Nat.lt_of_add_one_le igeN]
      ¬∑ contrapose! vne0; apply Mxbij.1; rw [vne0]; simp
  have eq1 : ((fun x' ‚Ü¶ ‚Äñx' - x‚Äñ‚Åª¬π * ‚ÄñRz x' - Rz x - Mx (x' - x)‚Äñ) ‚àò d) =
      fun i : ‚Ñï ‚Ü¶ ‚Äñd i - x‚Äñ‚Åª¬π * ‚ÄñRz (d i) - Rz x - Mx (d i - x)‚Äñ := by ext i; simp
  have eq2 : (fun i : ‚Ñï ‚Ü¶ ‚Äñd i - x‚Äñ‚Åª¬π * ‚ÄñRz (d i) - Rz x - Mx (d i - x)‚Äñ) =
      fun i : ‚Ñï ‚Ü¶ ‚Äñd i - x‚Äñ‚Åª¬π * ‚ÄñRz (d i) - Rt (1 / (i : ‚Ñù)) - Rz x - Mx (d i - x - (1 / (i : ‚Ñù)) ‚Ä¢ v)‚Äñ := by
    ext i; rw [Rteq]; simp; left
    rw [sub_right_comm _ _ (Rz x), sub_sub (Rz (d i) - Rz x), add_comm, sub_add_cancel]
  have eq3 : (fun i : ‚Ñï ‚Ü¶ ‚Äñd i - x‚Äñ‚Åª¬π * ‚ÄñRz (d i) - Rt (1 / (i : ‚Ñù)) - Rz x - Mx (d i - x - (1 / (i : ‚Ñù)) ‚Ä¢ v)‚Äñ)
      =·∂†[atTop] (fun i : ‚Ñï ‚Ü¶ ‚Äñd i - x‚Äñ‚Åª¬π * ‚ÄñMx (d i - x - (1 / (i : ‚Ñù)) ‚Ä¢ v)‚Äñ)  := by
    rw [EventuallyEq, eventually_atTop]; use N
    intro i igeN; specialize hfd i igeN
    rw [hfd, Rxeq0, sub_self, zero_sub, neg_zero, zero_sub, norm_neg]
  rw [eq1, eq2] at deriv
  obtain deriv := Filter.Tendsto.congr' eq3 deriv
  let NMx : EuclideanSpace ‚Ñù (Fin n) ‚Üí ‚Ñù := fun z ‚Ü¶ ‚ÄñMx z‚Äñ
  let deriv' : ‚Ñï ‚Üí EuclideanSpace ‚Ñù (Fin n) := fun i ‚Ü¶ (‚Äñd i - x‚Äñ‚Åª¬π ‚Ä¢ (d i - x - (1 / (i : ‚Ñù)) ‚Ä¢ v))
  have eq4 : (fun i : ‚Ñï ‚Ü¶ ‚Äñd i - x‚Äñ‚Åª¬π * ‚ÄñMx (d i - x - (1 / (i : ‚Ñù)) ‚Ä¢ v)‚Äñ) =
      NMx ‚àò deriv' := by
    ext i; simp [NMx, deriv']; rw [norm_smul]; simp
  rw [eq4] at deriv
  have comap_le : Filter.comap NMx (ùìù 0) ‚â§ (ùìù 0) := by
    simp only [NMx]; exact comap1 v vne0 Mxbij
  obtain lim := Tendsto.of_tendsto_comp deriv comap_le
  let œÜ : EuclideanSpace ‚Ñù (Fin n) ‚Üí EuclideanSpace ‚Ñù (Fin n) :=
    fun z ‚Ü¶ if (‚Äñz‚Äñ = 0) then v else ‚Äñz‚Äñ‚Åª¬π ‚Ä¢ (z - v)
  have eq5 : deriv' =·∂†[atTop] œÜ ‚àò (fun i : ‚Ñï ‚Ü¶ (i : ‚Ñù) ‚Ä¢ (d i - x)) := by
    rw [EventuallyEq, eventually_atTop]
    have : 0 < ‚Äñv‚Äñ := by refine lt_of_le_of_ne (norm_nonneg v) ?_; symm; simp [vne0]
    specialize dtend ‚Äñv‚Äñ this; rcases dtend with ‚ü®N‚ÇÅ, dtend‚ü©
    use max N‚ÇÅ N.succ; intro i igeN; simp only [ge_iff_le, max_le_iff] at igeN
    specialize dtend i igeN.1
    have neq : ‚Äñ(i : ‚Ñù) ‚Ä¢ (d i - x)‚Äñ ‚â† 0 := by
      rw [norm_smul]; apply mul_ne_zero; simp; linarith [Nat.lt_of_add_one_le igeN.2]
      specialize dne i igeN.2; simp; apply sub_ne_zero_of_ne dne
    field_simp [deriv', œÜ, neq]; apply eq_lemma neq
  obtain lim' := Filter.Tendsto.congr' eq5 lim
  refine Filter.Tendsto.of_tendsto_comp lim' ?_
  simp only [œÜ]; exact comap2 vne0

/-
  Linearized feasible directions equal tagent cone when LICQ holds
  Numerical Optimization, Nocedal & Wright, Lemma 12.2
-/

theorem LICQ_linearized_feasible_directions_sub_posTangentCone
    (x : EuclideanSpace ‚Ñù (Fin n)) (xf : x ‚àà p.FeasSet)
    (conte : ‚àÄ i ‚àà œÑ, ContDiffAt ‚Ñù (1 : ‚Ñï) (equality_constraints p i) x)
    (conti : ‚àÄ i ‚àà œÉ, ContDiffAt ‚Ñù (1 : ‚Ñï) (inequality_constraints p i) x)
    (LIx : p.LICQ x) (hdomain : p.domain = univ):
    p.linearized_feasible_directions x ‚äÜ posTangentConeAt p.FeasSet x := by
  intro v hv

  by_cases veq0 : v = 0
  ¬∑ rw [veq0]; rw [posTangentConeAt]; simp
    use fun n ‚Ü¶ n; use fun _ ‚Ü¶ 0; simp; constructor
    ¬∑ use 0; exact fun _ _ ‚Ü¶ xf
    ¬∑ exact tendsto_natCast_atTop_atTop

  let gradc : EuclideanSpace ‚Ñù (Fin n) ‚Üí ((p.active_set x) ‚Üí (EuclideanSpace ‚Ñù (Fin n))) :=
    fun z ‚Ü¶ (fun i ‚Ü¶ if i.1 ‚àà œÑ then gradient (p.equality_constraints i) z
      else gradient (p.inequality_constraints i) z) -- gradient of the constraints
  let Ax : Matrix (p.active_set x) (Fin n) ‚Ñù := fun i ‚Ü¶ gradc x i -- Jacobi at x
  let m := (p.active_set x).card
  have mlen : m ‚â§ n := by apply LICQ_mlen x LIx; simp [m]
  have existZ : ‚àÉ (Z : Matrix (Fin n) (Fin (n - m)) ‚Ñù), Ax * Z = 0 ‚àß Matrix.rank Z = (n - m) := by
    apply LICQ_existZ x LIx; simp [m]; simp [Ax, gradc]
  rw [LICQ] at LIx;
  rw [posTangentConeAt]; simp only [eventually_atTop, ge_iff_le, mem_setOf_eq]
  rcases existZ with ‚ü®Z, ‚ü®eq1, eq2‚ü©‚ü©

  let Mx : EuclideanSpace ‚Ñù (Fin n) ‚ÜíL[‚Ñù] EuclideanSpace ‚Ñù (p.active_set x) √ó (Fin (n - m) ‚Üí ‚Ñù) :=
    (LinearMap.toContinuousLinearMap (Matrix.toEuclideanLin Ax)).prod
    (LinearMap.toContinuousLinearMap (Matrix.toEuclideanLin Z·µÄ)) -- Jacobi of Rz at x
  let c : EuclideanSpace ‚Ñù (Fin n) ‚Üí ((p.active_set x) ‚Üí ‚Ñù) :=
    fun z ‚Ü¶ (fun i ‚Ü¶ if i.1 ‚àà œÑ then (p.equality_constraints i) z
      else (p.inequality_constraints i) z) -- the constraints
  let Rz : EuclideanSpace ‚Ñù (Fin n) ‚Üí EuclideanSpace ‚Ñù (p.active_set x) √ó (Fin (n - m) ‚Üí ‚Ñù) :=
    fun z ‚Ü¶ (c z, Z·µÄ *·µ• (z - x)) -- z part in R
  let Rt : ‚Ñù ‚Üí EuclideanSpace ‚Ñù (p.active_set x) √ó (Fin (n - m) ‚Üí ‚Ñù) := fun t ‚Ü¶ t ‚Ä¢ Mx v -- t part in R
  let A : EuclideanSpace ‚Ñù (Fin n) ‚Üí Matrix (p.active_set x) (Fin n) ‚Ñù :=
    fun z ‚Ü¶ (fun i ‚Ü¶ gradc z i) -- compose the gradient matrix
  let Jz : EuclideanSpace ‚Ñù (Fin n) ‚Üí EuclideanSpace ‚Ñù (Fin n) ‚ÜíL[‚Ñù] EuclideanSpace ‚Ñù (p.active_set x) :=
    fun z ‚Ü¶ (LinearMap.toContinuousLinearMap (toEuclideanLin (A z))) -- change the Jacobi into linear transformation
  have cgrad_atx : Jz x = (LinearMap.toContinuousLinearMap (toEuclideanLin Ax)) := by simp [Jz, A, gradc] -- A x = Ax

  have Rzgrad : HasStrictFDerivAt Rz Mx x := by
    simp only [Rz, Ax]
    apply HasStrictFDerivAt.prod
    ¬∑ rw [‚Üê cgrad_atx]
      rw [hasStrictFDerivAt_euclidean]
      refine LICQ_strictfderiv_Ax_elem c ?_ gradc ?_ A ?_ Jz ?_ conte conti
      repeat simp only [c, gradc, A, Jz]
    ¬∑ let N : EuclideanSpace ‚Ñù (Fin n) ‚ÜíL[‚Ñù] (Fin (n - m) ‚Üí ‚Ñù) := (LinearMap.toContinuousLinearMap (toEuclideanLin Z·µÄ))
      show HasStrictFDerivAt (fun y : EuclideanSpace ‚Ñù (Fin n) ‚Ü¶ Z·µÄ *·µ• (y - x)) N x
      rw [HasStrictFDerivAt]
      have aux : (fun p : EuclideanSpace ‚Ñù (Fin n) √ó EuclideanSpace ‚Ñù (Fin n)
          ‚Ü¶ Z·µÄ *·µ• (p.1 - x) - Z·µÄ *·µ• (p.2 - x) - N (p.1 - p.2)) = 0 := by
        ext y j; rw [‚Üê mulVec_sub, sub_sub, add_sub_cancel]; rw [mulVec_eq_toEuclidean]
        simp [N]; apply sub_eq_zero_of_eq; tauto
      rw [aux]; simp

  have Rxeq0 : Rz x = 0 := by
    simp [Rz, c]; ext i;
    simp [FeasSet, FeasPoint] at xf
    rcases xf with ‚ü®‚ü®_, h12‚ü©, _, _‚ü©
    by_cases h1 : i.1 ‚àà œÑ
    ¬∑ simp [h1]; exact h12 i h1
    ¬∑ simp [h1]; have hi := i.2; simp [active_set, h1] at hi; rcases hi with ‚ü®_, hi1‚ü©
      exact hi1

  have Mxinj : LinearMap.ker Mx = ‚ä• := by
    show LinearMap.ker (Mx : EuclideanSpace ‚Ñù (Fin n) ‚Üí‚Çó[‚Ñù] EuclideanSpace ‚Ñù (p.active_set x) √ó (Fin (n - m) ‚Üí ‚Ñù)) = ‚ä•
    rw [LinearMap.ker_eq_bot']
    intro z Mzeq0; simp [Mx] at Mzeq0
    have heq1 : Ax *·µ• z = 0 := by rw [mulVec_eq_toEuclidean]; apply Mzeq0.1
    have heq2 : Z·µÄ *·µ• z = 0 := by rw [mulVec_eq_toEuclidean]; apply Mzeq0.2
    refine LICQ_injM z m Z Ax ?_ mlen ?_ eq2 eq1 ‚ü®heq1, heq2‚ü©
    simp [m]
    obtain hAx := LICQ_Axfullrank x LIx; simp at hAx
    show Ax.rank = (active_set x).card; apply hAx; simp only [Ax]
  have Mxsurj : LinearMap.range Mx = ‚ä§ := by
    show LinearMap.range (Mx : EuclideanSpace ‚Ñù (Fin n) ‚Üí‚Çó[‚Ñù] EuclideanSpace ‚Ñù (p.active_set x) √ó (Fin (n - m) ‚Üí ‚Ñù)) = ‚ä§
    rw [‚Üê LinearMap.ker_eq_bot_iff_range_eq_top_of_finrank_eq_finrank]
    ¬∑ apply Mxinj
    ¬∑ simp; show n = m + (n - m)
      rw [add_comm, Nat.sub_add_cancel]; apply mlen

  use (fun n ‚Ü¶ n)

  have implicit_f: ‚àÉ (N : ‚Ñï) (d : ‚Ñï ‚Üí EuclideanSpace ‚Ñù (Fin n)), (‚àÄ m ‚â• N, Rz (d m) = Rt (1 / m)) ‚àß
      (Filter.Tendsto d atTop (ùìù x)) := by
    refine LICQ_implicit_f v ?_ Rxeq0 Rzgrad Mxsurj; simp [Rt]

  clear cgrad_atx
  simp only [linearized_feasible_directions] at hv
  rcases hv with ‚ü®hvh1, hvh2‚ü©
  rcases implicit_f with ‚ü®N, d, hfd, dtend‚ü©
  rw [LinearMapClass.ker_eq_bot] at Mxinj
  rw [LinearMap.range_eq_top] at Mxsurj
  obtain deriv := (hasFDerivAt_iff_tendsto.1 (HasStrictFDerivAt.hasFDerivAt Rzgrad))
  obtain deriv := tendsto_nhds_iff_seq_tendsto.1 deriv d dtend
  rw [tendsto_iff_norm_sub_tendsto_zero, NormedAddCommGroup.tendsto_nhds_zero] at dtend; simp at dtend
  obtain ‚ü®Œµ, Œµpos, inactive‚ü© := LICQ_inactive_nhds x xf conti
  obtain ‚ü®N', dtendx‚ü© := dtend Œµ Œµpos

  use (fun n ‚Ü¶ d n - x); constructor
  ¬∑ use max N N'; intro nn hnn; simp [FeasSet, FeasPoint]
    specialize hfd nn (le_of_max_le_left hnn); simp [Rz, Rt, Mx] at hfd; rw [‚Üê mulVec_eq_toEuclidean] at hfd
    rcases hfd with ‚ü®hv1, hv2‚ü©
    have Axeq : (nn : ‚Ñù)‚Åª¬π ‚Ä¢ Ax *·µ• v = fun i : (p.active_set x) ‚Ü¶ ((nn : ‚Ñù)‚Åª¬π * (gradc x i) ‚¨ù·µ• v) := by
      simp [Ax]; ext i; simp; left; simp [mulVec]
    have Axroweq : ‚àÄ i : (p.active_set x), c (d nn) i = (nn : ‚Ñù)‚Åª¬π * (gradc x i) ‚¨ù·µ• v := by
      rw [Axeq] at hv1; simp [hv1]
    constructor; constructor
    ¬∑ rw [hdomain]; simp
    ¬∑ intro i hi
      have iina : i ‚àà (p.active_set x) := by simp [active_set, hi]
      obtain h := hvh1 i hi
      obtain eq := Axroweq ‚ü®i, iina‚ü©; simp [c, hi, gradc] at eq
      rw [eq]; simp; right; apply h
    constructor
    ¬∑ rw [hdomain]; simp
    ¬∑ intro j hj
      have notin : j ‚àâ œÑ := by
        by_contra hh;
        have : j ‚àà œÑ ‚à© œÉ := by simp [hj, hh]
        rw [p.eq_ine_not_intersect] at this; tauto
      by_cases hj1 : j ‚àà p.active_set x
      ¬∑ have jin : j ‚àà œÉ ‚à© (p.active_set x) := by simp [hj1, hj]
        obtain h := hvh2 j jin
        obtain eq := Axroweq ‚ü®j, hj1‚ü©; simp [c, hj1, notin, gradc] at eq
        rw [eq]; field_simp
        rw [div_nonneg_iff]; left; simp at h; simp [dotProduct, h]
      ¬∑ specialize inactive j; simp [hj, hj1] at inactive
        specialize inactive (d nn)
        specialize dtendx nn (le_of_max_le_right hnn); rw [‚Üê dist_eq_norm] at dtendx
        specialize inactive dtendx; linarith [inactive]

  constructor
  ¬∑ exact tendsto_natCast_atTop_atTop
  ¬∑ have Mxbij : Function.Bijective Mx := ‚ü®Mxinj, Mxsurj‚ü©
    refine LICQ_tendsto v veq0 ?_ Rxeq0 hfd dtend Mxbij deriv; simp [Rt]

theorem LICQ_linearized_feasible_directions_eq_posTangentCone
    (x : EuclideanSpace ‚Ñù (Fin n)) (xf : x ‚àà p.FeasSet)
    (conte : ‚àÄ i ‚àà œÑ, ContDiffAt ‚Ñù (1 : ‚Ñï) (equality_constraints p i) x)
    (conti : ‚àÄ i ‚àà œÉ, ContDiffAt ‚Ñù (1 : ‚Ñï) (inequality_constraints p i) x)
    (LIx : p.LICQ x) (hdomain : p.domain = univ):
    p.linearized_feasible_directions x = posTangentConeAt p.FeasSet x := by
  have diffable : ‚àÄ i ‚àà œÑ, DifferentiableAt ‚Ñù (equality_constraints p i) x :=
    diffable_of_hasgradient_nhds conte
  have diffable‚ÇÇ : ‚àÄ i ‚àà œÉ, DifferentiableAt ‚Ñù (inequality_constraints p i) x :=
    diffable_of_hasgradient_nhds conti
  apply Set.Subset.antisymm
  ¬∑ exact LICQ_linearized_feasible_directions_sub_posTangentCone x xf conte conti LIx hdomain
  ¬∑ exact linearized_feasible_directions_contain_tagent_cone xf diffable diffable‚ÇÇ

theorem local_minima_linearized_feasible_directions_LICQ (loc : EuclideanSpace ‚Ñù (Fin n))
    (hl : p.Local_Minima loc) (hf : Differentiable ‚Ñù p.objective)
    (conte : ‚àÄ i ‚àà œÑ, ContDiffAt ‚Ñù (1 : ‚Ñï) (equality_constraints p i) loc)
    (conti : ‚àÄ i ‚àà œÉ, ContDiffAt ‚Ñù (1 : ‚Ñï) (inequality_constraints p i) loc)
    (LIx : p.LICQ loc) (hdomain : p.domain = univ) :
    p.linearized_feasible_directions loc ‚à© {d | ‚ü™gradient p.objective loc, d‚ü´_‚Ñù < (0 : ‚Ñù)} = ‚àÖ := by
  obtain h := local_minima_TangentCone' loc hl hf
  rw [LICQ_linearized_feasible_directions_eq_posTangentCone]
  apply h; apply hl.1; use conte; use conti; exact LIx; exact hdomain

theorem local_minima_linearized_feasible_directions_LICQ' (loc : EuclideanSpace ‚Ñù (Fin n))
    (hl : p.Local_Minima loc) (hf : Differentiable ‚Ñù p.objective)
    (conte : ‚àÄ i ‚àà œÑ, ContDiffAt ‚Ñù (1 : ‚Ñï) (equality_constraints p i) loc)
    (conti : ‚àÄ i ‚àà œÉ, ContDiffAt ‚Ñù (1 : ‚Ñï) (inequality_constraints p i) loc)
    (LIx : p.LICQ loc) (hdomain : p.domain = univ):
    ¬¨ ‚àÉ d : EuclideanSpace ‚Ñù (Fin n), d ‚àà p.linearized_feasible_directions loc
      ‚àß ‚ü™gradient p.objective loc, d‚ü´_‚Ñù < (0 : ‚Ñù) := by
  simp only [not_exists, not_and, not_lt]
  rw [LICQ_linearized_feasible_directions_eq_posTangentCone]
  apply local_minima_TangentCone;
  apply hl; exact hf;
  apply hl.1; use conte; use conti; exact LIx; exact hdomain

theorem local_minima_linearized_feasible_directions_LICQ'' (loc : EuclideanSpace ‚Ñù (Fin n))
    (hl : p.Local_Minima loc) (hf : Differentiable ‚Ñù p.objective)
    (conte : ‚àÄ i ‚àà œÑ, ContDiffAt ‚Ñù (1 : ‚Ñï) (equality_constraints p i) loc)
    (conti : ‚àÄ i ‚àà œÉ, ContDiffAt ‚Ñù (1 : ‚Ñï) (inequality_constraints p i) loc)
    (LIx : p.LICQ loc) (hdomain : p.domain = univ):
    ¬¨ ‚àÉ d : EuclideanSpace ‚Ñù (Fin n), (‚àÄ i ‚àà œÑ, ‚ü™gradient (p.equality_constraints i) loc, d‚ü´_‚Ñù = 0)
      ‚àß (‚àÄ j ‚àà œÉ ‚à© p.active_set loc, ‚ü™gradient (p.inequality_constraints j) loc, d‚ü´_‚Ñù ‚â• 0)
      ‚àß (‚ü™gradient p.objective loc, d‚ü´_‚Ñù < (0 : ‚Ñù)) := by
  obtain h := local_minima_linearized_feasible_directions_LICQ' loc hl hf conte conti LIx
  unfold linearized_feasible_directions at h
  simp only [mem_setOf_eq] at h
  by_contra hh; apply absurd h; push_neg; rcases hh with ‚ü®d, ‚ü®hd1, hd2, hd3‚ü© ‚ü©
  constructor; exact hdomain; use d

lemma subtype_sum (œÉ œÑ : Finset ‚Ñï) (f : œÉ ‚Üí EuclideanSpace ‚Ñù (Fin n))
    (g : {x // x ‚àà œÉ ‚à© œÑ} ‚Üí EuclideanSpace ‚Ñù (Fin n))
    (h2 : ‚àÄ i : {x // x ‚àà œÉ ‚à© œÑ}, g i =
      f {val := i.1, property := by obtain hi := i.2; simp at hi; exact hi.1})
    (h3 : ‚àÄ i : œÉ, i.1 ‚àâ œÑ ‚Üí f i = 0) :
    ‚àë i, f i = ‚àë i, g i := by
  have : ‚àë i, g i = ‚àë i : {x // x ‚àà œÉ ‚à© œÑ},
      f {val := i.1, property := by obtain hi := i.2; simp at hi; exact hi.1} := by
    congr; ext i; rw [h2]
  rw [this]; simp [h3]
  let f‚ÇÅ : ‚Ñï ‚Üí EuclideanSpace ‚Ñù (Fin n):= fun i => if h : i ‚àà œÉ then f ‚ü®i, h‚ü© else 0
  have eq1 : ‚àë i ‚àà œÉ.attach, f i = ‚àë i in œÉ, f‚ÇÅ i := by
    simp [f‚ÇÅ]; nth_rw 2 [‚Üê Finset.sum_attach]; congr; simp
  have eq2 : ‚àë i ‚àà (œÉ ‚à© œÑ).attach,
      f {val := i.1, property := by obtain hi := i.2; simp at hi; exact hi.1} =
      ‚àë i ‚àà (œÉ ‚à© œÑ), f‚ÇÅ i := by
    simp [f‚ÇÅ]; nth_rw 2 [‚Üê Finset.sum_attach]; congr; ext x j
    have : x.1 ‚àà œÉ := Finset.mem_of_mem_inter_left x.2
    simp [this]
  rw [eq1, eq2]
  obtain eq := Finset.sdiff_union_inter œÉ œÑ
  nth_rw 1 [‚Üê eq]; rw [Finset.sum_union]; simp
  have feq0 : ‚àÄ x ‚àà (œÉ \ œÑ), f‚ÇÅ x = 0 := by
    simp [f‚ÇÅ]; intro x _ xninœÑ
    intro h; specialize h3 ‚ü®x, h‚ü©; apply h3; simp [xninœÑ]
  apply Finset.sum_eq_zero feq0
  apply Finset.disjoint_sdiff_inter œÉ œÑ

/-
  Karush‚ÄìKuhn‚ÄìTucker conditions
  Numerical Optimization, Nocedal & Wright, Theorem 12.1
-/
theorem first_order_neccessary (p1 : Constrained_OptimizationProblem (EuclideanSpace ‚Ñù (Fin n)) œÑ œÉ)
    (loc : EuclideanSpace ‚Ñù (Fin n)) (hl : p1.Local_Minima loc)
    (hf : Differentiable ‚Ñù p1.objective)
    (conte : ‚àÄ i ‚àà œÑ, ContDiffAt ‚Ñù (1 : ‚Ñï) (equality_constraints p1 i) loc)
    (conti : ‚àÄ i ‚àà œÉ, ContDiffAt ‚Ñù (1 : ‚Ñï) (inequality_constraints p1 i) loc)
    (hLICQ : p1.LICQ loc)
    (hdomain : p1.domain = univ) : p1.FeasPoint loc ‚àß (‚àÉ (lambda1 : œÑ ‚Üí ‚Ñù) (lambda2 : œÉ ‚Üí ‚Ñù),
    (gradient (fun m ‚Ü¶ (p1.Lagrange_function m lambda1 lambda2)) loc = 0) ‚àß (‚àÄ j : œÉ, lambda2 j ‚â• 0) ‚àß
    (‚àÄ j : œÉ, (lambda2 j) * (p1.inequality_constraints j loc) = 0)) := by
  constructor
  ¬∑ exact hl.1
  ¬∑ obtain h := local_minima_linearized_feasible_directions_LICQ'' loc hl hf
    have he1 : ‚àÄ i ‚àà œÑ, DifferentiableAt ‚Ñù (p1.equality_constraints i) loc :=
      diffable_of_hasgradient_nhds conte
    have hc1 : ‚àÄ i ‚àà œÉ, DifferentiableAt ‚Ñù (p1.inequality_constraints i) loc :=
      diffable_of_hasgradient_nhds conti
    specialize h conte conti hLICQ hdomain
    rw [‚Üê Farkas (c := gradient p1.objective loc)] at h
    rcases h with ‚ü®lam, mu, ‚ü®h1, h2‚ü©‚ü©
    let mu1 : œÉ ‚Üí ‚Ñù := fun i ‚Ü¶ if k : i.1 ‚àà p1.active_set loc then
      mu {val := i.1, property := by simp [k]} else 0
    use lam; use mu1; constructor
    ¬∑ unfold Lagrange_function
      rw [gradient_sub, gradient_sub, gradient_sum, gradient_sum]; rw [h2]
      rw [sub_sub, ‚Üê sub_add_sub_comm];
      have : ‚àë x , lam x ‚Ä¢ gradient (p1.equality_constraints x) loc - ‚àë i,
          gradient (fun m => lam i * p1.equality_constraints i m) loc = 0 := by
        rw [‚Üê Finset.sum_sub_distrib]; apply Finset.sum_eq_zero
        intro i _; rw [gradient_const_mul']; simp
        exact (he1 i i.2)
      rw [this, zero_add, sub_eq_zero]; symm;
      have : ‚àë i, gradient (fun m => mu1 i * p1.inequality_constraints (‚Üëi) m) loc =
          ‚àë i, mu1 i ‚Ä¢ gradient (p1.inequality_constraints (‚Üëi)) loc := by
        congr; ext i; rw [‚Üê gradient_const_mul']; exact (hc1 i i.2)
      rw [this];
      let f := fun i ‚Ü¶ mu1 i ‚Ä¢ gradient (p1.inequality_constraints ‚Üëi) loc
      let g := fun i ‚Ü¶ mu i ‚Ä¢ gradient (p1.inequality_constraints ‚Üëi) loc
      have : ‚àë i, f i = ‚àë i, g i := by
        apply subtype_sum œÉ (p1.active_set loc) f g
        ¬∑ intro i; simp [f, g]; simp [mu1];
          obtain hi := i.2; simp at hi; simp [hi.2]
        intro i hi; simp [f]; left; simp [mu1, hi]
      simp only [f, g] at this; exact this
      intro i _; apply DifferentiableAt.const_mul; exact (hc1 i i.2)
      intro i _; apply DifferentiableAt.const_mul; exact (he1 i i.2)
      exact hf.differentiableAt
      apply DifferentiableAt.sum; intro i _; apply DifferentiableAt.const_mul
      exact (he1 i i.2)
      apply DifferentiableAt.sub hf.differentiableAt
      apply DifferentiableAt.sum; intro i _; apply DifferentiableAt.const_mul
      exact (he1 i i.2)
      apply DifferentiableAt.sum; intro i _; apply DifferentiableAt.const_mul
      exact (hc1 i i.2)
    constructor
    ¬∑ intro j
      simp [mu1]
      by_cases ht : j.1 ‚àà p1.active_set loc
      ¬∑ simp [ht]; exact h1 {val := j, property :=by simp [ht]}
      simp [ht]
    intro j
    simp [mu1];
    by_cases ht : j.1 ‚àà p1.active_set loc
    ¬∑ simp [ht]; right;
      have heq : j.1 ‚àà œÉ ‚à© p1.active_set loc := by
        simp [ht]
      unfold active_set at heq
      simp at heq
      rcases heq with hl | hl
      ¬∑ obtain neq := p1.eq_ine_not_intersect
        exfalso;
        have : j.1 ‚àà œÑ ‚à© œÉ := by simp [hl]
        apply absurd neq; push_neg;
        apply Finset.ne_empty_of_mem
        exact this
      exact hl
    simp [ht]

end Constrained_OptimizationProblem_property_finite_dimensional
